<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Nicholas Ch&#39;s blog</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content in Posts on Nicholas Ch&#39;s blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 11 Jul 2024 15:56:35 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Compile-time Security Controls: Bridging the Gap Beyond SAST</title>
      <link>http://localhost:1313/posts/compile-time-security-control/</link>
      <pubDate>Thu, 11 Jul 2024 15:56:35 +0800</pubDate>
      <guid>http://localhost:1313/posts/compile-time-security-control/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; &lt;em&gt;I am not a compiler expert. This article&amp;rsquo;s goal is to express the possibility of how we can look at compile-time security controls for Application Security.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;what-is-sast&#34;&gt;What is SAST?&lt;/h1&gt;&#xA;&lt;p&gt;Static Application Security Testing (SAST) involves the scanning of static application code before it is compiled. The scan usually involves a parser to check for security vulnerabilities before the code is compiled.&lt;/p&gt;&#xA;&lt;h1 id=&#34;the-limitations-of-sast&#34;&gt;The limitations of SAST&lt;/h1&gt;&#xA;&lt;p&gt;SAST scanners will look for known or configured insecure coding patterns by parsing source files. Parsing source files typically involves building an abstract syntax tree (AST) data structure, where each node represents a specific token and its relationship with other tokens. However, the limitation of SAST scanners is the lack of richer semantics of each token.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Offensive Security Web Expert Review</title>
      <link>http://localhost:1313/posts/oswe-review/</link>
      <pubDate>Fri, 12 May 2023 17:07:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/oswe-review/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;oswe-logo.png&#34; alt=&#34;oswe&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;precursor-to-the-coursework&#34;&gt;Precursor to the coursework&lt;/h1&gt;&#xA;&lt;p&gt;I started the OSWE coursework around the middle of 2022. Before that, I had done the following:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;PortSwigger labs - SQLi, XSS, XXE, File upload vulnerabilities, Path traversal, Command Injection, Server-side template injection&lt;/li&gt;&#xA;&lt;li&gt;Pentesterlab Pro - Essential badge, couple of Code review labs&lt;/li&gt;&#xA;&lt;li&gt;Cleared the eLearnsecurity Professional Penetration Tester (eCPPTv2) certification&lt;/li&gt;&#xA;&lt;li&gt;Constantly reading up disclosed bug bounty reports&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;I also had done many different programming projects in Java, C/C++, Python, PHP, Javascript, SQL. It’s definitely beneficial to have a background in software development and having worked with different programming languages. Even if you don’t have such a background, achieving the OSWE is still possible because it mainly requires you to understand application logic flow in a language agnostic fashion.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
